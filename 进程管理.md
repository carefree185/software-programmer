# 一、进程管理

也称为处理机管理，目的式合理分配处理机得时间，提高系统的效率。在计算机系中有多个并发执行的程序，采用"程序"不能描述程序执行时的动态变化的过程，因此引入了"进程"
## 1.1 基本概念
1.  **程序执行时的特征** 

    ![](https://images.gitee.com/uploads/images/2021/0119/175225_bea53a9f_7841459.png "屏幕截图.png")

    前驱图是一个有向无循环图，节点代表程序段的操作，连接节点的边表示节点之间的前驱关系。

    程序顺序执行时主要特征有**顺序性、封闭性、可再现性**
    * 顺序性。程序段严格按照规定的顺序执行
    * 封闭性。程序运行时系统内的资源只受该程序控制而改变，执行结果不受外界因数改变
    * 可再现性。在相同的环境和初始条件下，程序执行多次的结果相同。

    ![](https://images.gitee.com/uploads/images/2021/0119/192013_1ba467ee_7841459.png "屏幕截图.png")
    
    计算机系统采用多道程序设计技术，则主存中的多道程序并发执行。如上图的三个程序，同一个作业内没有前驱关系的程序段或不同的作业程序段可以分别在CPU和各输入输出设备上并发执行。

    程序并执行时的特征
    * 失去程序的封闭性
    * 程序和机器执行程序的活动不在一一对应
    * 并发程序间具有相互制约

2. **进程的组成**
    
    进程(Process)时程序的一次执行。进程通常由**程序、数据和进程控制块(Process Contorl Block)**组成。其中PCB是进程存在的唯一标识，主要内容如下表
    ![](https://images.gitee.com/uploads/images/2021/0119/192646_f20deb89_7841459.png "屏幕截图.png")
    
    进程的程序部分描述了进程需要完成的功能。如果程序可以被多个进程同时共享执行，则这部分就应该以可再入码的形式编制，是程序中不可修改的部分。

    进程的数据部分包括程序执行时需要的数据及工作区， **只能被一个程序所专用** ，是进程可以修改的部分。

3. 进程的状态及其状态间的切换

    在多道程序系统中，进程的运行是走走停停，在处理器上交替运行，状态也不断的发送变化。进程一般有3种基本状态： **运行、就绪、阻塞**，如下图；

    ![](https://images.gitee.com/uploads/images/2021/0119/193205_258e631b_7841459.png "屏幕截图.png")
    *  **运行态** ： **进程在处理机上执行时** ，称该进程处于运行状态。显然，单处理机系统，处于运行状态的进程只有一个。
    *  **就绪态** ： **进程获得了处理机外的一切所需资源**，一旦获得处理机即可运行，则称为进程的就绪态。
    *  **阻塞态** ：**进程正在等待某一事件发生**(例如，I/O事件)而暂时停止运行，这时即使把处理机分配给该进程也无法运行，故称该状态为阻塞态。
    
    进程状态还可以分为五种: **新建、就绪、运行、阻塞、终止**
    ![](https://images.gitee.com/uploads/images/2021/0119/195415_f3a2c992_7841459.png "屏幕截图.png")
    * **新建态** : 进程刚被创建还没有被提交的状态，并等待系统完成创建的所有必要信息。新建进程需要经过两个阶段: 第一阶段，为一个新进程创建必要的管理信息；第二阶段，让进程进入就绪态。新建态可以使操作系统根据系统的性能和内存容量限制推迟新建态进程的提交。
    * **终止态** ： **进程停止运行的状态** ，分为两个阶段：第一阶段，等待操作系统进行善后处理；第二阶段，释放内存。终止态的目的是防止系统进行善后处理时引起资源分配不当等问题。

## 1.2 进程控制

进程控制是指对系统中所有进程从创建到消亡的全过程实施有效控制。操作系统中通过设置一套控制机构对进程实施控制，主要功能包括**创建一个新进程、撤销一个已经运行完成的进程、改变进程状态、实现进程间通信**。由操作系统内核中的原语实现。

原语(Primitive)是指若干条机器指令组成的、用于完成特定功能的程序段。特点: **在执行时不能分割(原子操作)**，内核原语主要包括**进程控制原语、进程撤销原语、进程挂起原语、进程激活原语、进程阻塞原语、进程唤醒原语等**。大多数系统内核都包含**支撑功能和资源管理功能**

## 1.3 进程通信

在多道程序环境的系统中，存在多个可并发执行的进程，因此进程间必然存在资源共享的相互合作的问题。 **进程通信指各个进程交换信息的过程** 。

1. 同步与互斥
    
    多个并发执行的进程都以各自独立的、不可预知的速度向前推进，但是有时需要在某些确定点上协调相互合作进程间的工作。

     **进程间同步是指进程间完成一项任务时直接发生相互作用的关系** 。例如，进程A和进程B，当进程B从缓冲区取出数据时，进程A已经完成了向缓冲区写入数据的操作，如果缓冲区中没有数据，则进程B将等待进程A向缓冲区写入数据。

   在多道程序系统中，各进程可以共享资源，但是有些资源只能被一个进程占用。只能被一个进程占用的资源称为临界资源(Critical Resource)。 **进程间互斥是指系统中进程互斥使用临界资源。** 

    临界区(Critical Section)是进程中对临界资源实施财政的程序段。互斥临界区管理的4个原则
    1. **有空即进** ：无程序处于临界区时，允许进程进入临界区，并且只能在临界区允许有限的时间
    2. **无空则等** ：当有一个进程在临界区时，其他需要进入临界区的进程必须等待，以保证进程互斥地访问临界资源
    3. **有限等待** ：对要访问临界资源地进程，应保证进程等待有限时间后进入临界区，以免陷入"饥饿"状态
    4. **让权等待** ：当进程不能进入自己的临界区时，应立即释放处理机，以免进程陷入"忙等"状态

2. 信号量机制

    信号量是一种有效的进程同步与互斥工具。信号量分为**整型型号量、记录型信号量、信号量集机制**
    
    **整型信号量**是指信号量是一个整型变量，根据不同的控制对象赋予不同的值。信号量分为两类
    1. 公用信号量：实现进程间的互斥，初始值为1或资源的数目

    2. 私用信号量：实现进程间的同步，初始值为0或某个整数

    信号量$S$的物理意义: 若$S\ge 0$, 表示某资源的可用书；若$S\lt 0$, 则其绝对值表示阻塞队列中等待该资源的进程数。

    **PV操作**是实现进程同步与互斥的常用方法。P操作和V操作是低级通信原语，执行期间不可分割。**P操作表示申请资源，V操作表示释放资源**

    ```pv
    Procedure P(Var S:Semaphore);
        Begin
            S:=S-1;
        If S<0 then W(S) {执行P操作的进程插入等待队列}
        End;
    ```
    * 若$S\ge 0$，则执行P操作的进程继续执行
    * 若$S\lt 0$, 则该进程为阻塞状态(因为无资源可用)，并将其插入阻塞队列
    
    ```pv
    Procedure V(Var S:Semaphore)
        Begin
            S:=S+1;
            If S<= 0 then R(S) {从阻塞队列中唤醒一个进程}
        End;
    ```
    * 若$S\gt 0$, 则执行V操作的进程继续执行
    * 若$S\le 0$, 则从阻塞状态中唤醒一个进程，并将其插入就绪队列，然后执行V操作的进程继续

    * **PV操作实现进程的互斥**: 令信号量mutex的初始值为1，进入临界区时执行P操作，退出临界区执行V操作
        ```PV
        P(mutex)
        临界区
        V(mutex)
        ```
    * **PV操作实现进程的同步**：并发执行的进程间的相互合作而引起相互制约的问题。实现进程同步的一种方法是将一个信号量与消息相联系，当信号量为0时表示消息未产生，否则表示消息已经来到。(**单缓冲区的生产者消费者模型**)

3. 高级通信

    根据进程间信息量的多少和效率的高低分为低价通信方式和高级通信方式。PV操作属于低级通信方式，存在如下问题
    * **编程难度大，通信对用户不透明**，即需要用户利用低级通信工具实现进程间的同步与互斥，而且 **PV操作使用不当容易引起死锁** 
    * **效率低**，生产者每次只能向缓冲区放一个消息，消费者每次只能从缓冲区取一个消息。
    
    为了提高通信效率，能传递大量数据，减轻程序的复杂度，引入了高级通信方式，主要有**共享存储模式、消息传递模式、管道通信**
    * 共享存储模式。相互通信的进程共享某个数据结构(或存储区)，实现进程之间的通信
    * 消息传递模式。进程间数据交换以消息为单位，直接利用系统提供的一组通信命令来实现通信(`Send(A), Receive(A)`)
    * 管道通信。管道用于连接两个进程，一个读数据，一个写数据，实现进程的相互通信。

4. 直接和简接通信
    
    直接通信是将消息直接发送给指定进程，应该在Send和Receive原语中指定进程名字
    ```PV
    Send(Who, Message), 发送消息个指定进程或一组进程
    Receive(Who, Message), 从约定进程接受消息
    ```
    间接通信是以信箱为媒体来实现通信，接收信件的进程只需设立一个信箱，若干个进程可以向同一个进程发送信件，应该在Send和Receive原语中给出信箱名
    ```pv
    Send(M,N), 将信件M发送给信箱N
    Receive(N,X), 从信箱N中取一封信件存入X
    ```
    还有系统提供了带标记的发送，用Tag可以指定进程是否要等到接收进程取到信息在继续运行。一般接收进程总是要等待消息到达后才继续运行。

## 1.4 进程调度

1. 三级调度
    
    某些操作系统中，一个作业从提交到完成需要经历高中低三级调度。
    * **高级调度**。又称"长调度、作业调度、接纳调度"， **决定处于输入池中的哪个后备作业可以调入主系统做好运行准备，成为一个或一组就绪进程** 。**系统中一个作业只需经过一次高级调度**
    * **中级调度**。又称"中程调度、对换调度"， **决定处于交换区中的就绪进程哪个可以调入内存** ，以便于直接参与对CPU的竞争。在内存资源紧张时，为了将进程调入内存，必须将内存中处于阻塞状态的进程调出至交换区，以便为调入进程腾出空间。
    * **低级调度**。又称"短程调度、进程调度"， **决定处于内存中的就绪进程那个可占用CPU** ，是操作系统中最活跃、最重要的调度程序，对系统的影响很大。

2. 进程调度方式

    进程调度方式是指当更高优先级的进程来到时如何分配CPU。调度方式分为**可剥夺和不可剥夺**两种方式
    * **可剥夺方式**: 当更高优先级的进程来到时，强行剥夺正在运行进程的CPU分配给更高优先级的进程。
    * **不可剥夺方式**：当更高优先级的程序到来时，必须等待正在运行进程自动释放占用的CPU，然后将CPU分配个更高优先级的进程

3. 进程调度算法

    常用的进程调度算法有**先来先服务、时间片轮转、优先级调度、多级反馈调度**算法
    1. **先来先服务(First Come First Served, FCFS)**。 **按照作业提交或进程变为就绪状态的先后次序分配CPU** ，即每当进入进程调度时，总是将就绪队列队首的进程投入运行。FCFS调度算法有利于长作业，有利于计算密集型作业；不利于I/O繁忙的作业。 **主要用于宏观调度**。

    2. **时间片轮转**。主要用于微观调度，目的时提高资源利用率。可以提高进程并发性和响应时间特性，从而提高资源利用率。时间片的长度选择方法一般有两种
        * **固定时间片**。分配给每个进程相等的时间片，所有进程都公平执行，是一种简单有效的方法。
        * **可变时间片**。根据进程不同的要求对时间片的大小实时修改，可以更好地提高效率。

    3. **优先级调度**。让每一个进程都拥有一个优先数，通常数值大地表示优先级高，系统在调度时总选择优先级高地占用CPU。优先级调度分为**静态优先级和动态优先级**
        *  **静态优先级** 。 **进程的优先级在创建时确定，直到终止也不会改变** 。确定优先级的因素有进程类型(系统进程优先级高)、对资源的需求(对CPU和内存需求较少的进程优先级高)、用户要求(紧迫程度和付费多少)
        *  **动态优先级** 。 **创建进程时赋予一个优先级，在进程运行过程中还可以改变，以便于获取更好的调度性能** 。例如，就绪队列中，随着等待时间增长，优先级将提高。这样对于优先级低的进程在等待足够时间后，其优先级提高到可被调度执行。进程每执行一个时间片后，优先级降低，从而当一个进程持续执行时，其优先级会降低到让出CPU。

    4. **多级反馈调度**。 **时间片轮转算法和优先级算法的综合与发展** 。优点是照顾短进程以提高系统吞吐量、缩短了平均周转时间；照顾I/O型进程以获得较好的I/O设备利用率和缩短响应时间不必估计进程的执行时间，动态调节优先级。

## 1.5 死锁

计算机系统中有各种互斥资源和软件资源，若两个进程互相要求对方已经占用的资源，或者同时进入临界区则会出现问题。 **死锁是指两个以上的进程互相都要求使用对方已经占用的资源而导致无法继续运行的现象** 。





