# 内存管理

## 一、内存区间

* C/C++定义了4个内存区间
  * 代码区/全局变量与静态变量区/局部变量区(栈区)/动态存储区(堆区)	
    * 代码区: 存放代码, 一般只读.
    * 静态存储区: 编译器在编译时可以根据该变量的类型确定所需要的内存空间大小. 从而系统在适当的时候为他们分配确定的存储区域. 一旦内存空间建立完成, 就会持续到程序运行结束在释放.
    * 栈区: 执行函数时, 函数内的局部变量的存储单元都可以在栈上创建. 函数执行结束时, 内存单元自动释放.
    * 堆区: 程序运行时, 才能确定对象占用的内存空间. 编译器无法为他们预定存储空间. 只能在程序运行时, 系统根据运行时的要求进行内存分配.
      * 所有动态存储分配都在堆区中进行
      * 可以使用`malloc`函数可以在堆上申请空间. 这个空间有我们自行管理. 释放时使用函数`free`进行内存释放.

## 二、动态内存

* 动态内存的申请
  * 申请内存空间:`void *malloc(size_t  num)`
    * `num`: 表示要申请内存的字节数.
    * 只关心内存的字节数, 不识别要申请的内存是什么类型
    * 申请到的内存是一块连续的内存空间; 返回申请到内存的首地址, 这个首地址要保护好, 释放内存时要使用.. 有时可能申请不到内存空间, 此时返回`NULL `
    * 返回值的类型为`void  *`, 所以在调用`malloc`函数时要显示的进行类型转换. 将`void *`转换为需要的指针类型.
  * 释放内存空间: `void  free(void  *ptr)`
    * 参数是`NULL`时没有任何效果
    * 释放一个内存块的一部分是不被允许的.
* 注意时事项:
  * `free(p)`: 表示释放`p`指针指向的堆空间,内存释放后`p`指针仍然指向堆空间, 但此时的堆空间是自由空间.不能使用. 此时指针`p`为野指针.
  * 如果`malloc`函数返回的指针丢失, 会出现分配内存无法回收, 称为内存泄漏.
  * 同一个空间释放两次是非法的. 
* 野指针
  * 指向的内存空间不能进行操作. 野指针非常危险
  * 造成原因
    * 指针变量没有初始化
    * 指针`p`指向的内存被释放(`free(p)`)后没有被置空(`p=NULL`)
    * 指针操作越过了变量作用内存范围.

**示例程序**

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>


typedef struct student
{
    int no;
    char name[20];
    float score;
}Stu;

Stu * get_std()
{
    Stu * s;

    if((s=(Stu *)malloc(sizeof(Stu)))==NULL)
    {
        printf("内存申请失败\n");
        return  NULL;
    }
    s->no = 10;
    strcpy(s->name, "小明");
    s->score = 87;
    return s;
}

int main()
{
    Stu *p;
    if ((p=get_std())==NULL){
        goto END;
    } 
    else
    {
        printf("student info: %d-%s-%.2f\n", p->no, p->name, p->score);
        free(p);
    }
END:
    return 0;
}
```

