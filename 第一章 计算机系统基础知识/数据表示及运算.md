# 一、计算机中数据表示
计算机内部，数字、文字、声音、图形图像等各种信息都必须经过数字化编码后才能被传送、存储和处理。

 **编码就是采用少量的基本符号，选取一定的组合规则，来表示大量复杂的信息**
信息编码的两大要素
1. 基本符号

2. 符合的组合规则

例如；用10个阿拉伯数码表示数字，用26个英文字母表示英文词汇等


## 1.1 进位计数制及其转换

只用`r`个基本符号表示数值，则称其为`r`进制，`r`称为该数制的基数。不同数制都具有如下特点
1. 每一种数制都有固定的符号集；例如十进制基本符号有`0~9`十个基本符号，二进制有`0，1`两个基本符号

2. 每一种数制都使用位置表示法，处于不同位置的数符代表的值不同，与它所在位置的权值有关。 **第$i$号位置(从右到左以$0$开始计数)的权值为$r^i$** 例如：
$$
1234.56 = 1 \times 10^3 + 2 \times 10^2 + 3 \times 10 + 4 \times 10^0 + 5 \times 10^{-1} + 6 \times 10^{-2}
$$

在计算机中常用的进位计数制有二进制、八进制、十进制和十六进制

|进位制|	二进制|	八进制|	十进制|	十六进制|
|:---:|:---:|:---:|:---:|:---:|
|规则| 逢二进一 |逢八进一|逢十进一|逢十六进一|
|基数|r=2|r=8|r=10|r=16|
|数符|$0,1$|$0,1,\cdots,7$|$0,1,\cdots,9$|$0,1,\cdots,9, A, \cdots, F$|
|权|$2^i$|$8^i$|${10}^i$|${16}^i$|
|表示符|B|O|D|H|

十进制数按权展开后得到仍然是十进制，其位权值恰好是10的某个次幂。对于其他进制也是相同的。所以， **由任何一种进制表示的数都可以按权展开转换为十进制数** 。

1.  **十进制数与二进制数的相互转换**
    
    十进制计数制中，$r=10$，基本符号为$0,1,\cdots,9$

    二进制计数制中，$r=2$，基本符号为$0$和$1$。二进制数中的一个$0$或$1$称为1位(bit)。

    将十进制数转为二进制数时，整数部分和小数部分要分开转换，然后合并。
整数部分转换为二进制整数方法是：**除以 2 取余数，将余数反序排列**，小数部分转为二进制小数方法是：**乘 2 取整，将整数部分顺序排列**

2.  **十进制数转换为八进制数或十六进制数** 

    理解十进制数转为二进制数后，十进制数转为其他进制也是相同原理。整数部分: **除以 基数r 取余数，将余数反序排列**；小数部分：**乘 基数r 取整，将整数部分顺序排列**

3.  **二进制与八进制相互转换** 

    从小数点开始， **每三位二进制位分成一组** (不足 3 位时，在小数左边就在左边补 0，在小数点右边就在右边补 0)， **每一组都对应一位八进制数** 。然后写出每一组的等值八进制数 **顺序排列** 即可。

4.  **二进制与十六进制相互转换**  

    从小数点开始， **每四位二进制位分成一组** (不足 4 位时，在小数左边就在左边补 0，在小数点右边就在右边补 0)， **每一组都对应一位十六进制数** 。然后写出每一组的等值十六进制数 **顺序排列** 即可。

|二进制|八进制|
|:---:|:---:|
|$000$|$0$|
|$001$|$1$|
|$010$|$2$|
|$011$|$3$|
|$100$|$4$|
|$101$|$5$|
|$110$|$6$|
|$111$|$7$|

|二进制|十六进制|
|:---:|:---:|
|$0000$|$0$|
|$0001$|$1$|
|$0010$|$2$|
|$0011$|$3$|
|$0100$|$4$|
|$0101$|$5$|
|$0110$|$6$|
|$0111$|$7$|
|$1000$|$8$|
|$1001$|$9$|
|$1010$|$A$|
|$1011$|$B$|
|$1100$|$C$|
|$1101$|$D$|
|$1110$|$E$|
|$1111$|$F$|

## 1.2 二进制运算规则
* 逢二进一，借一当二
* 0乘任何数得0，1称任何数得它本身

## 1.3 机器数与码制
&emsp;&emsp;&emsp;&emsp;各种数据在计算机中表示的形式称为 **机器数** ，特点是采用 **二进制计数制** 。小数点隐含表示而不占位置。机器数对应的实际值称为数的真值。

&emsp;&emsp;&emsp;&emsp;对于有符号数，机器数最高位表示符号位；其余表示数值位。小数点的位置在机器数的最低位置则是纯整数，小数点的位置在机器数数值位的最高位置(符号位之后)则是纯小数。

&emsp;&emsp;&emsp;&emsp;有符号数可以采用原码、反码、补码和移码等不同编码方式进行表示

### 1.3.1 原码表示
数值$X$的原码记为$[X]_{原}$，如果机器字长为$n$(采用$n$个二进制位表示数据)，则最高位是符号位， **$0$表示正，$1$表示负，其余$n-1$位表示数值的绝对值** 。数值原码表示时，数值零有两种形式: $[+0]_{原}=00\cdots00$, $[-0]_{原}=10\cdots00$

### 1.3.2 反码表示
数值$X$的原码记为$[X]_{反}$，如果机器字长为$n$，则最高位是符号位， $0$表示正，$1$表示负，其余$n-1$位表示数值。 **正数的反码与原码相同，负数的反码则是其绝对值按位取反**。数值反码表示时，数值零有两种形式: $[+0]_{反}=00\cdots00$, $[-0]_{反码}=11\cdots11$

### 1.3.3 补码表示
数值$X$的原码记为$[X]_{补}$，如果机器字长为$n$，则最高位是符号位， $0$表示正，$1$表示负，其余$n-1$位表示数值。 **正数的补码与原码相同，负数的补码等于反码末尾加1**。数值补码表示时，数值零有唯一形式表示: $[+0]_{补}=00\cdots00$, $[-0]_{补}=00\cdots00$

### 1.3.4 移码表示
移码表示法是在数值$X$上增加一个偏移量来定义，常用于表示浮点数中的阶码。如果机器字长位$n$，在偏移量位$2^{n-1}$时， **移码等于补码符号位取反** 。采 **用补码表示时，码值大者对应的真值就大** 

### 1.3.5 四种码制表示
设机器字长$n=8$
1. 原码表示
    $$
    [+1]_原 = 00000001 \qquad [-1]_原 = 10000001 \\
    [+127]_原 = 01111111 \qquad [-127]_原 = 11111111 \\
    [+0.5]_原 = 0.1000000 \qquad [-0.5]_原 = 1.1000000
    $$
    
2. 反码表示
    $$
    [+1]_反 = 00000001 \qquad [-1]_反 = 11111110 \\
    [+127]_反 = 01111111 \qquad [-127]_反 = 10000000 \\
    [+0.5]_反 = 0.1000000 \qquad [-0.5]_反 = 1.0111111
    $$

3. 补码表示
    $$
    [+1]_补 = 00000001 \qquad [-1]_补 = 11111111 \\
    [+127]_补 = 01111111 \qquad [-127]_补 = 10000001 \\
    [+0.5]_补 = 0.1000000 \qquad [-0.5]_补 = 1.1000000
    $$
    * 补码表示时，存在的特殊状况：符号位为1，数值为全为0，表示的是整数$-2^{n-1}$
    * 补码表示数时，由于符号位和数值位一同编码，在补码值上很难判断出真值大小

4. 移码表示
    $$
    [+1]_移 = 10000001 \qquad [-1]_移 = 01111111 \\
    [+127]_移 = 11111111 \qquad [-127]_移 = 00000001 \\
    [+0]_移 = 10000000 \qquad [-0]_移 = 10000000
    $$

### 1.3.6 原码、补码、反码的相互转换
对于正数，原码、补码和反码完全相同。

下面讨论负数的情况
1. 已知原码求反码：符号位不变，数值位按位取反
2. 已知原码求补码: 符号位不变，数值位按位取反再加1
3. 已知反码求补码: 符号位不变，数值位加1
4. 已知补码求反码: 符号位不变，数值位加1 
5. 已知补码求原码: 符号位不变，数值位按位取反再加1( **补码的补码为原码** )

**移码真值=移码-偏移量**

## 1.4 定点数与浮点数

### 1.4.1 定点数
定点数是指表示数据时 **小数点位置固定不变** 。小数点的位置有两种约定方式
1.  定点整数，纯整数，小数点约定再数值为之后
2. 定点小数，纯小数，小数点约定再最高有效数值为之前(符号位之后)

设机器字长为$n$，各种码制表示有符号数的范围

|码制|定点整数|定点小数|
|:---:|:---:|:---:|
|原码|$[-(2^{n-1}-1),+(2^{n-1}-1)]$|$[-(1-2^{-(n-1)}),+(1-2^{-(n-1)})]$|
|反码|$[-(2^{n-1}-1),+(2^{n-1}-1)]$|$[-(1-2^{-(n-1)}),+(1-2^{-(n-1)})]$|
|补码|$[-2^{n-1},+(2^{n-1}-1)]$|$[-1,+(1-2^{-(n-1)})]$|
|移码|$[-2^{n-1},+(2^{n-1}-1)]$|$[-1,+(1-2^{-(n-1)})]$|


### 1.4.2 浮点数
浮点数是指小数点位置不固定的数，表示数的范围更大。再十进制中实数可以有多种表示形式。例如：$83.125$可以表示为$10^3 \times 0.083125$或$10^4 \times 0.0083125$，同样的，一个二进制数也可以写成多种形式。例如：$1011.10101$可以表示为$2^4 \times 0.101110101$或$2^5 \times 0.0101110101$等形式

二进制数可以表示为如下形式
$$
N=2^E \times F
$$
其中，$E$称为阶码 $F$称为尾数。这种方式称为浮点表示法；浮点表示法通常规定阶码($E$)为有符号的纯整数，尾数($F$)为有符号的纯小数。一般表示形式如下：
![](https://images.gitee.com/uploads/images/2021/0106/224020_7abae254_7841459.png "屏幕截图.png")
这种方式浮点数表示不唯一，当小数点位置发生变化时，阶码也会发生变化。

浮点数表示的范围由阶码决定，表示精度由尾数决定。为了提高数据表示的精度，当尾数不为 0 时，规定尾数最高有效位为 1，这是 **浮点数的规格化表示** 。不满足规格化的浮点数应该调整阶码的同时移动小数点位置，使其变为规格化形式的浮点数。

规格化就是将尾数的绝对值限定再$[0.5, 1)$内
1. 若尾数$F\ge 0$, 则尾数的规格化形式为$F=01xx \cdots x$,$x$可以为0也可以为1; 也即是将尾数限定再$[0.5, 1)$ 
2. 若尾数$F \lt 0$, 则尾数的规格化形式为$F=10xx \cdots x$,$x$可以为0也可以为1; 也即是将尾数限定再$(-1, -0.5)$ 

**工业标准IEEE 754  浮点数规格化标准** 

IEEE 754标准被广泛采用，该标准的表示形式如下

![](https://images.gitee.com/uploads/images/2021/0106/230901_db3fcf3c_7841459.png "屏幕截图.png")
其中
* $S$为数的符号，$0$表示正，$1$表示负
* $P$为指数(阶码)，用移码表示(偏移值$2^{p-1}-1$, $p$为阶码位数)
* $M$为尾数，用原码表示

**关于$P=0或255$的特殊规定** 
* $P=0, M=0$，表示真值为$\pm 0$(符号由$S$确定)
* $P=255, M=0$, 表示真值为$\pm \infty$(符号由$S$确定)
* $P=255, M \ne 0$, 表示不是一个数(`NaN`)

在IEEE 754标准中，单精度浮点数与双精度浮点数，约定小数点左边隐含一位，通常是 1， 因此尾数为$1.xxx\cdots$

IEEE 754标准在计算机中主要使用的形式
|参数|单精度浮点数|双精度浮点数|扩充精度浮点数|
|:---:|:---:|:---:|:---:|
|浮点数字长|32|64|80|
|尾数长度|23|52|64|
|符号位长度|1|1|1|
|阶码长度|8|11|15|
|阶码偏移值|$+127$|$+1023$|$+16383$|
|范围|$[10^{-38},10^{38}]$|$[10^{-308},10^{308}]$|$[10^{-4932},10^{4932}]$|

## 1.5 十进制数与字符的编码表示

数值、文字和英文字母都被认为是字符，任何字符被录入计算机后，都必须转换成二进制表示形式，称为字符串编码

**BCD码**：用 4 为二进制数表示一位十进制数，称为二-十进制编码，简称BCD码
* $2^4 = 16$，而十进制只有0~9十个不同的数符，所以BCD编码有多种。根据是否带权分为有权码和无权码
    * 有权码；8421-BCD码，二进制的位权从高到低分别为8、4、2、1.
    * 无权码；余 3 码和格雷码；其中余3码是在8421码的基础上，把每个数的代码加上0011后构成；格雷码，指相邻两个代码之间只有一位不同

十进制数与8421BCD码、余3码、格雷码对应表
|十进制数|8421BCD码|余3码|格雷码|
|:---:|:---:|:---:|:---:|
|0|0000|0011|0000|
|1|0001|0100|0001|
|2|0010|0101|0011|
|3|0011|0110|0010|
|4|0100|0111|0110|
|5|0101|1000|1110|
|6|0110|1001|1010|
|7|0111|1010|1000|
|8|1000|1011|1100|
|9|1001|1100|0100|

## 1.6 ASCII码
ASCII码(美国标准信息交换码)被国际标准组织ISO采纳，成为国际通用的信息交换码。基本的ASCII码采用7位二进制数表示，也即是$d_6d_5d_4d_3d_2d_1d_0$。低四位组$d_3d_2d_1d_0$作为行编码，高三位组$d_6d_5d_4$作为列编码
![](https://images.gitee.com/uploads/images/2021/0107/115206_1b3f4bc9_7841459.png "屏幕截图.png")
更具ASCII码表可快速确定字符对应的二进制数

## 1.7 汉字编码
在计算机中处理汉字，必须将汉字代码化，即对汉字进行编码。汉字处理需要经过输入、内部处理、存储和输出过程，每个过程需要的汉字代码都不相同，采用的编码也不同。

* **输入码** 
  
    汉字字数很多，字形复杂，字音多变。为了能直接使用西文标准键盘输入汉字，汉字输入码分为三类:  **数字编码、拼音码和字形码** 
    * 数字编码: 数字串代表汉字，常用国标区位码(国家标准局公布的6763个汉字分为94个区，每个区94位。区码和位码各两位十进制数。例如，‘中’位于54区48位)；
        * 区位码: 1~15区表示字母数字和符号，16~87区表示一级和二级汉字(一级汉字: 汉语拼音排序；二级汉字：偏旁部首排序)
        * 特点；输入无重码，且与内部码转换方便。但是数字编码记忆困难
    * 拼音编码： **汉语读音** 为基础设计的输入码
        * 特点；重码率高
    * 字形编码：以汉字的形状设计的输入码，由于 **组成汉字的部件和笔画有限的** 。常见的字形编码是五笔字形编码。

* **内部码** 
  
    汉字内部码是汉字在设备和信息处理系统内部存储、处理和传输汉字使用的代码。由于汉字的数量巨大，一个字节无法区分；国家标准局`GB2312-1980`中规定的汉字国标码，采用两个字节存放一个汉字的内码；每个字节的最高位为1表示作为汉字机内码，由于两个字节各用来七位来表示汉字，总共可以表示16384个汉字机器内码。
    
    我国最新的内码字符集是GB18030-2005 《信息计数中文编码字符集》，与`GB2312-1980`完全兼容，支持GB13000和Unicode的全部统一汉字，共收录了70244个

* **字形码**

    汉字字形码是表示汉字字形的字模数据。通常采用点阵、矢量函数等方式表示。它是汉字的输出方式。点阵法表示时，根据输出汉字的要求不同，点阵多少也不同。简易汉字采用$16\times16$点阵，高精度型汉字采用$24\times24, 32\times 32, 48\times 48$；点阵法表示的字形码信息量很大，所占的存储空间也很大。所以汉字的字形码以字库的形式存储在硬盘中，当要显示输出时，才会检索字库，输出字形。
    
    汉字的矢量表示法是将汉字看作由笔画组成的图形，提取每个笔画的坐标值，将每一个汉字所有的坐标信息组合起来就是该字的字形码。同样每一个汉字的矢量信息集中在一起构成字库。当要输出汉字时，利用字形检索程序根据机器内码找到相应的字形码输出汉字

## 1.8 Unicode编码

为了统一表示世界各个国家的文字，国际标准化组织1993年公布了 ‘通用多八位编码字符集’(ISO/IEC 10646)简称UCS。而Unicode时软件制造协会开发的可以容纳世界上所有文字和字符的字符编码标准，包括字符集、编码方案等。Unicode2.0采用了与ISO 10646-1相同的字库和字码。目前两个项目独立公布各种的标准

UCS规定了两种编码格式: UCS-2(采用2个字节编码)和UCS-4(采用4个字节编码，最高位必须为0)

Unicode定义了用于传输和保存的UTF-8、UTF-16、UTF-32等，广泛使用的是UTF-8

# 二、校验码
计算系统运行时，各个部件要进行数据交换，为例确保数据在传输过程中正确无误；提高硬件电路的可靠性和代码的校验能力，包括差错和纠错。使用校验码来检测传送数据是否出错，也即是将数据的编码分为两类： **合法编码和错误编码**。
* 合法编码用于传送数据，错误编码不允许出现在数据的编码中。

码距是指编码系统中任意两个合法编码之间至少由多少个二进制位不同。例如8421BCD码的码距是1，在传输过程中，该代码的一位或多位发生错误，都将编程另一个合法编码；这样的代码无查错能力。

常用的3种校验码：奇偶校验码、海明码、循环冗余校验码。
## 2.1 奇偶校验码
增加一位校验位使得代码中 1 的个数位奇数(奇校验码)或偶数(偶校验码)
    
奇偶校验码使的码距变成2，但是只能校验代码中奇数位出错的编码，不能校验出偶数位出错的情况。奇偶校验码只能校验出错误，不能纠正错误

常用的奇偶校验码有3种：水平奇偶校验码、垂直奇偶校验码、水平垂直校验码

1. 水平奇偶校验码：添加的校验位与信息位处于用一行
2. 垂直奇偶校验码：将数据分成若干组，一组占一行，排列整齐，最后在添加一行校验码。针对每一列采用奇校验或偶检验
3. 水平垂直校验码：在垂直校验的基础上对每组数据添加一位水平校验位。

## 2.2 海明码
海明码是使用奇偶性来查错和纠错的。海明码的构成方法是在数据位种插入$k$个校验位，通过扩大码距来实现检错和纠错。(默认位偶检验)

**海明码编码过程如下**
1. 确定校验码位数：$n+k\le 2^k-1$其中$k$是校验码位数，$n$是数据位数

2. 确定校验位在海明码中的分布：规定第$i$个校验位设置在海明码的$2^{i-1}$位置上其中$i=1,2,\cdots$

3. 分组校验：每个数据为需要多个校验位进行校验，但是需要满足的是 **被校验数据的
海明码位号等于校验该数据位的各校验码海明码位号的和**，就可以确定每个校验位需要校验的数据位，将它们作为一组。

4. 确定校验位的值：每个校验位校验的数据位的异或值作为校验值(奇校验，则将计算出的值取反即可)

5. 检测错误：计算每组(包括校验位)异或值。如果每组异或值全为0则数据没有错误(奇校验，则每组的异或值全为 1)。如果不全为0，则发生错误；由每组异或值组成的十进制值指出了错误的位置，将错误位置取反即可

**以8位数据位为例**
1. 确定校验码位数: $8+k\le 2^k - 1 $ 计算出$k=4$
    * 数据位为: $D_7, D_6, D_5, D_4, D_3, D_2, D_1, D_0$
    * 校验位为：$P_4, P_3, P_2, P_1$
    * 海明码为：$H_{12}, H_{11}, H_{10}, H_9, H_7, H_6, H_5, H_4, H_3, H_2, H_1$

2. 确定海明码与数据为和校验位对应关系。第$i$位校验位设置在海明码的第$2^{i-1}$位

    ![](https://images.gitee.com/uploads/images/2021/0107/160010_f2a472f2_7841459.png "屏幕截图.png")

3. 确定数据位需要的校验位
    ![](https://images.gitee.com/uploads/images/2021/0107/161906_1a8012f7_7841459.png "屏幕截图.png")
    * 确定分组情况
        ![](https://images.gitee.com/uploads/images/2021/0107/162703_05220573_7841459.png "屏幕截图.png")

4. 计算校验位的值
![](https://images.gitee.com/uploads/images/2021/0107/162917_0b676567_7841459.png "屏幕截图.png")
* 奇校验则取反

5. 错误检测
![](https://images.gitee.com/uploads/images/2021/0107/163152_0aed3c4e_7841459.png "屏幕截图.png")
如果$G_4G_3G_2G_1$全为零，则表示接收数据无错误(奇校验则全位1)，否则则是出现了错误。并且$G_4G_3G_2G_1$的十进制数就是错误发生的位置。例如：$G_4G_3G_2G_1=1010$则是$H_{10}(D_5)$出现错误，将$D_5$取反即可

## 2.3 循环冗余校验码
应用于通信领域和磁介质存储系统中，利用生成多项式位$k$个数据位产生$r$个校验位来进行编码，编码长度为$k+r$ ，称为CRC码

循环冗余校验码由两部分组成，左边为信息码(数据)，右边为校验码。若信息码占$k$为，校验码占$n-k$位，$n$位CRC码的字长。所以也称为$(n, k)$校验码。校验码由信息码产生，校验位越长，校验能力越强。求CRC编码采用 **模2** 运算

# 三、逻辑代数及逻辑运算
逻辑代数是用代数的方式对逻辑变量进行描述和分析的数学工具。

**基本逻辑运算** 
* "与"运算: 逻辑 与，用符号$AND, \bigcap, \bigwedge, \cdot$表示, 设逻辑变量$A$和$B$；$A \bigwedge B$为真当且仅当$A$和$B$同时为真(**同真则真，一假则假**) 
* "或"运算: 逻辑 或，用符号$OR, \bigvee, +$表示, $A \bigvee B$为假当且仅当$A$和$B$为真。
* "非"运算: 逻辑 求反，常用$\overline{A}$表示。$\overline 1 = 0, \overline 0 = 1$

* "异或"运算：也称半加运算，用符号$\bigoplus$或$XOR$表示，$A \bigoplus B$为真当且仅当$A$和$B$不同时为真或不同时为假

**常用逻辑运算公式**
![](https://images.gitee.com/uploads/images/2021/0108/115142_1b387150_7841459.jpeg "微信图片_20210108115126.jpg")

**逻辑表达式的真值及化简**
逻辑表达式是逻辑运算符把逻辑变量连接起来的表示逻辑关系的表达式。罗列出每个逻辑变量的真值组成的表称为真值表(证明逻辑表达式成立)

使用逻辑运算规律和常用逻辑恒等式可以对逻辑表达式进行化简。

# 四、机器数的运算
## 4.1 机器数的加减运算
在计算机中，可以只设置加法运算器，减法运算使用将其转化为加法运算进行
### 4.1.1 原码的加法
**规则** 
* 相同符号的数相加，数值位相加，符号位不变
* 符号不同的数相加，先比价两数的绝对值，用绝对值大的减去绝对值小的，符号位取绝对值大的符号

### 4.1.2 补码的加法
**规则** 
* $[X+Y]_补 = [X]_补 + [Y]_补$
* $[X-Y]_补 = [X]_补 + [-Y]_补码$
* 已知$[X]_补$，则$[-X]_补$为$[X]_补$按位取反加(包括符号位) 1

**过程**
1. 参与运算的数用补码表示
2. 符号位参与运算
3. 加法，则两数相加；减法，则将减数连同符号位取反加 1 后，与被减数相加

### 4.1.3 溢出判断
确定了运算字长和数据的表示方法后，数据表示范围则确定。运算结果超出了数据表示范围就会发生溢出。

只有当两个相同符号的数相加(或相异符号的数相减)才会发生溢出

常用的移出检测机制主要以下几种
1. 双符号位判断: $00$表示正，$11$表示负。数据溢出则会出现符号位不一致

2. 进位判决法：$C_{n-1}$表示最高数值位向最高位的进位，$C_n$表示符号位的进位，则$C_{n-1}\bigoplus C_n=1$表示溢出

3. 根据结果的符号和进位标志判断: $VF=SF \bigoplus CF$

4. 根据运算前后符号位进行判读: $VF=X_s\cdot Y_s \cdot \overline {Z_s} + \overline{X_s} \cdot \overline{Y_s} \cdot Z_s$($X_s, Y_s, Z_s$表示符号位)

## 4.2 机器数的乘除运算

实现乘除运算的3种方式
1. 纯软件方案，抵挡计算机中只有加法器，没有乘除指令，乘除运算是用程序来完成的
2. 在能够完成加减运算的算术逻辑单元$ALU$上通过增加实现左移位和右移位的逻辑电路实现乘除运算；增加的硬件少，运算速度快
3. 设置专用的硬件阵列乘法器(或除法器)，完成乘(除)运算；付出更高的硬件代价，但是运算速度快

## 4.3 浮点数运算
### 4.3.1 浮点数的加减运算
设浮点数$X=M\times 2^i$, $Y=N\times 2^j$, 求$X\pm Y$的过程如下
1. 对阶。使两个数的阶码相同。令$K=|i-j|$,把阶码小的数的尾数右移$K$位，使其阶码加上$K$
2. 尾数求和(差)
3. 结果规格化，并判断溢出。非规格化，则进行规格化处理；若溢出，调整阶码
4. 舍入。进行右移时，低位将被丢弃。舍入处理方法如下
    * 截断法；将保留数据末位右边的数完全截断。
    * 末位恒1: 将保留数据的末位恒置为1
    * 0舍1入：保留数据末位后面的数为1，则进位。否则，舍去
5. 溢出判断。以阶码为准，若阶码溢出。则运算结果溢出；若阶码下溢，则结果为0，否则结果正确

### 4.3.2 浮点数的乘除法
1. 乘法
    * 规则
        * 积的阶码: 因数阶码的和
        * 积的尾数: 因数尾数的积
2. 除法
    * 规则
        * 商的阶码：被除数的阶码减去除数的阶码
        * 商的尾数：被除数的尾数除以除数的尾数

计算结果需要判断溢出和规格化处理