# 一 栈
栈(stack)是一种只能在一端进行插入和删除操作的线性表
* 允许进行插入删除操作的一端称为**栈顶**。
* 表的另一端称为**栈底**
* 栈的插入操作称为**入栈**
* 栈的删除操作称为**出栈**

**特点: LIFO， 后进先出**

## 栈的抽象数据类型

```
ADT Staxk
{
    数据对象:
        Data
    数据关系:
        Relation
    基本运算:
        InitStack(**S): 初始化线性表，构造一个空的线性表L
        DestroyStack(*S): 销毁线性表
        StackEmpty(*S): 判断线性表是否为空表
        Push(*S, e): 入栈
        Pop(*S, *e): 出栈
        GetTop(*S, *e): 获取栈顶元素
}
```

## 栈数据结构的实现
```c
//
// Created by dyp on 2021/4/23.
//

#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

#define MaxSize 50

typedef struct  {
    int date[MaxSize];
    int top;
}SeqStack;

void InitStack(SeqStack **S) {
    /**
     * 初始化空栈
     */

    *S = (SeqStack *) malloc(sizeof(SeqStack));
    (*S)->top = -1;
}

void DestroyStack(SeqStack **S) {
    /**
     * 销毁栈
     */

    free(*S);
    *S = NULL;
}

bool StackEmpty(SeqStack *S) {
    /**
     * 判断栈空
     */

    return S->top == -1;
}

bool Push(SeqStack *S, int e) {
    /**
     * 入栈操作
     */

    if (S->top == MaxSize - 1) {
        return false;
    }
    S->date[++S->top] = e;
    return true;
}


bool Pop(SeqStack *S, int *e) {
    /**
     * 出栈操作
     */

    if (S->top == -1) return false;

    *e = S->date[S->top--];
    return true;
}

bool GetTop(SeqStack *S, int *e) {
    /**
     * 取出栈顶元素
     */

    if (S->top == -1) {
        return false;
    }
    *e = S->date[S->top];
    return true;
}

int main() {
    SeqStack  *S=NULL;
    InitStack(&S);
    for (int i = 0; i < 10; i++) {
        Push(S, i+1);
    }
    for (int i = 0; i < 10; i++) {
        int e = 0;
        Pop(S, &e);
        printf_s("%d ", e);
    }
    printf_s("\n");
}
```

入栈和出栈的时间复杂度为$O(n)$


# 队列

队列(queue)是一种讲插入操作和删除操作限制在两端的的线性表。
* 插入端称为**队尾**
* 删除端称为**队首**
* 插入元素成为入队
* 删除元素称为出队

**特点: FIFO，先进先出（从尾入，从头出）**

## 队列的抽象数据类型
```
ADT Queue
{
    数据对象:
        Data
    数据关系:
        Relation
    基本运算:
        InitQueue(**S): 初始化线性表，构造一个空的线性表L
        DestroyQueue(*S): 销毁线性表
        QueueEmpty(*S): 判断线性表是否为空表
        enQueue(*S, e): 入队
        deQueue(*S, *e): 出队
}
```

## 队列数据结构的实现
![](.img/队列1.jpg)

```c
//
// Created by dyp on 2021/4/23.
//

#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

#define MaxSize 50

typedef struct {
    int data[MaxSize];
    int front, rear;
}SeqQueue;

void InitQueue(SeqQueue **Q) {
    /**
     * 初始化一个空队列
     */
    *Q = (SeqQueue *) malloc(sizeof(SeqQueue));
    (*Q)->front = (*Q)->rear = -1;
}

void DestroyQueue(SeqQueue **Q) {
    /**
     * 销毁队列
     */
    free(*Q);
    *Q = NULL;
}

bool QueueEmpty(SeqQueue *Q){
    /**
     * 队列是否为空
     */

    return Q->rear == Q->front;
}

bool enQueue(SeqQueue *Q, int e) {
    /**
     * 入队
     */

    if(Q->rear == MaxSize - 1) {  // 队列满
        return false;
    }

    Q->data[++Q->rear] = e;
    return true;
}

bool deQueue(SeqQueue *Q, int *e) {
    /**
     * 出队
     */

    if (Q->front == Q->rear) {
        return false;
    }
    *e = Q->data[++Q->front];
    return true;
}

int main() {
    SeqQueue  *q;
    InitQueue(&q);
    for(int i = 0; i < 10; i++) {
        enQueue(q, i+1);
    }

    for(int i = 0; i < 10; i++) {
        int e=0;
        deQueue(q,&e);
        printf_s("%d ", e);
    }
    printf_s("\n");
    return 0;
}
```
所用的操作时间复杂度为$O(1)$

但是，随着入队和出队的进行，当队尾指针指指向最大存储位置，如果之前发生了出队操作，
则该队列还有空闲位置，但是此时也不能插入数据，这就是队列的假溢现象。解决方法是
让指针变成循环的结构。也就是$front=(front+1)\%MaxSize, rear=(rear+1)\%MaxSize$
此时，队空与队满的条件是$front==rear$, 采用空一个存储位置方式解决。
此时，队空条件为$rear == front$，队满条件为$(rear+1)%MaxSize==front$.





