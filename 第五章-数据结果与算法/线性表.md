# 线性表

线性表(linear list)是具有相同特性的数据元素的有限序列
* 线性表中元素个数称为线性表长度$n$
* $n=0$表示空表
* 每个元素有逻辑序号唯一确定

## 一 线性表的抽象数据类型
```
ADT List
{
    数据对象:
        Data
    数据关系:
        Relation
    基本运算:
        InitList(**L): 初始化线性表，构造一个空的线性表L
        DestroyList(*L): 销毁线性表
        ListEmpty(*L): 判断线性表是否为空表
        ListLength(*L): 求线性表的长度
        DispList(*L): 输出线性表
        GetElem(*L, i, *e): 获取线性表中某个数据元素值
        LocateElem(*L,e): 查找元素e在线性表L中的索引
        ListInsert(*L, i, e): 在索引为i的位置，插入数据元素
        ListDelete(*L, i, *e): 删除索引为i数据元素，并返回
}
```

## 二 顺序表
线性表的顺序存储结构实现称为顺序表。就是将逻辑结构上相邻元素在物理结构上也相邻。

![](./.img/顺序表.png)

**顺序表基本实现**
```c
//
// Created by dyp on 2021/4/22.
//

#include <stdio.h>
#include <stdlib.h>

#define MaxSize 50
// 顺序表的定义
typedef struct {
    int data[MaxSize];  // 顺序存放数据
    int length; // 顺序表长度
}SeqList;

void InitList(SeqList **L){
    /**
     * 初始化顺序表，创建空表
     */
    *L = (SeqList *) malloc(sizeof(SeqList));  // 分配空间
    (*L)->length = 0;  // 初始化长度为0
}

void CreateList(SeqList **L, int *a, int n) {
    /**
     * 创建顺序表，并添加初始值
     */

    *L = (SeqList *) malloc(sizeof(SeqList));  // 分配空间

    for (int i = 0; i < n; i++) {
        *((*L)->data + i) = *(a+i);
    }
    (*L)->length = n;
}

void DestroyList(SeqList **L) {
    /**
     * 销毁顺序表
     */
    free(*L);
    *L = NULL;
}

void DispList(SeqList *L) {
    /**
     * 输出顺序表
     */
    for (int i = 0; i < L->length; i++) {
        printf("%d\t", *(L->data+i));
    }
    printf("\n");
}

_Bool ListEmpty(SeqList *L) {
    /**
     * 判断顺序表是否为空
     */
    return L->length == 0;
}

_Bool GetElem(SeqList *L, int i, int *e) {
    /**
     * 求i对应的元素，使用e返回
     */
    if (i < 1 || i > L->length){
        return 0;
    }
    *e = L->data[i-1];
    return 1;
}

int LocateElem(SeqList *L, int e) {
    /**
     * 操作e的位置
     */

    int i = 0;
    while (i < L->length && L->data[i] != e) {
        i++;
    }
    if (i >= L->length){
        return 0;
    }
    return i + 1;
}

_Bool ListInsert(SeqList *L, int i, int e) {
    /**
     * 向顺序表L的索引为i的位置插入e
     */
    int j;
    if(i < 1 || i > L->length + 1|| L->length == MaxSize) {
        return 0;
    }
    i--;
    for(j=L->length; j > i; j--) {
        L->data[j] = L->data[j - 1];
    }
    L->data[i] = e;
    L->length++;
    return 1;
}

_Bool ListDelete(SeqList *L, int i, int *e) {
    /**
     * 删除索引为i的元素
     */

    int j;
    if (i < 1 || i > L->length) {
        return 0;
    }
    i--;
    *e = L->data[i];
    for(j=i; j < L->length-1; j++) {
        L->data[j] = L->data[j+1];
    }
    L->length--;
    return 1;

}

int main(){
    int a[]={1,2,3,4,5,6};
    SeqList *L = NULL;

    CreateList(&L, a, sizeof(a)/ sizeof(int));
    DispList(L);
    int e=0;
    GetElem(L, 2, &e);
    printf_s("%d\n",e);
    printf_s("%d\n", LocateElem(L, 3));
    ListInsert(L, 1, 0);
    DispList(L);
    ListDelete(L, 2, &e);
    printf_s("%d\n",e);
    return 0;
}
```
插入数据时，移动的元素与表长`length`与插入位置`i`有关。
平均要移动的次数为$\sum_{i=1}^{n+1}p_i(n-i+1)=\sum_{i=1}^{n+1}\frac{1}{n+1}(n-i+1)$
$=\frac{1}{n+1}\sum_{i=1}^{n+1}(n-i+1)=\frac{1}{n+1}\times \frac{n(n+1)}{2}=\frac{n}{2}$
插入数据的时间复杂度为$O(n)$




