# 树
树是$n$个结点的有限集合。当$n=0$时称为空树。在任一非空树$n>0$中，
有且只有一个结点称为根节点；其余结点分为$m\ge 0$个互不相交的有限集合$T_1,T_2,\cdots T_m$,
其中每个集合都是一颗树，称为根节点的子树。

* 双亲、孩子和兄弟：结点的子树的根称为该结点孩子结点。该结点称为其子结点的双亲结点或父节点。
  具有相同双亲的结点称为兄弟结点。
  
* 结点的度：一个结点子树的个数。

* 叶子结点：终端结点，度为$0$的结点

* 内部结点：度不为$0$的结点，称为分支结点。除根节点外的分支结点称为内部结点

* 结点的层次：根结点为第一层，根的孩子结点为第二层，依次类推

* 树的高度：一棵树的最大层数记为树的高度。

* 有序树与无序树：树种结点的各个子树从左到右有次序关系，即不能交换子树顺序，则称为有序树；否则
  称为无序树
  
* 森林：是$m\ge 0$棵互不相交的树的集合

# 二叉树

二叉树是$n\ge 0$个结点的有限集合，是由一个根节点及两颗不相交的分别称为左子树和右子树
的二叉树组成。

* 二叉树中结点的度最大为2
* 区分左子树和右子树

## 二叉树的性质
* 二叉树的第$i\ge1$层上至多有$2^{i-1}$个结点

* 深度为$k$的二叉树至多有$2^k-1$个结点($k\ge 1$)

* 任何一颗二叉树，若其终端结点数为$n_0$，度为$2$的结点数$n_2$。则$n_0=n_2+1$

## 满二叉树和完全二叉树

* 满二叉树: 深度为$k$的二叉树有$2^k-1$个结点
* 完全二叉树: 深度为$k$有$n$个结点的二叉树，对结点进行层次编号时，编号与满二叉树
  一一对应。
  * 高度为$[\log_2n] + 1$

## 二叉树的存储结构
### 顺序存储结构
用一组地址连续的存储单元存储二叉树中的结点。在完全二叉树中，对于编号为$i$的结点
* 若$i=1$，则为根结点，无双亲；
* 若$i\gt 1$，则该结点的双亲结点为$[\frac{i}{2}]$
* 若$2i\le n$，则该结点的左孩子编号为$2i$，否则无左孩子
* 若$2i+1\le n$，则该结点的有孩子编号为$2i+1$，否则无右孩子

顺序存储结构适合存储完全二叉树，对于一般的二叉树需要在空间中存储虚结点造成空间浪费。

### 链式存储结构
二叉树中结点保护数据元素与左右子树的根结点信息，因此采用三叉链表存储。

结点定义如下
```c
typedef struct BiTnode {
    ElemType data;
    struct BiTnode *lchild,*rchild;
}BiTnode, *BiTree;
```

## 二叉树遍历

### 先序遍历
* 根
* 左
* 右

```c
void PreOrderTraverse(BiTree T)//二叉树的先序遍历
{
    if(T==NULL)
        return ;
    printf("%c ",T->data);
    PreOrderTraverse(T->lchild);
    PreOrderTraverse(T->rchild);
}
```
### 中序遍历
* 左
* 根
* 右

```c
void InOrderTraverse(BiTree T)//二叉树的中序遍历
{
   if(T==NULL)
       return ;
   InOrderTraverse(T->lchild);
    printf("%c ",T->data);
   InOrderTraverse(T->rchild);
}
```
### 后序遍历
* 左
* 右
* 根
```c
void PostOrderTraverse(BiTree T)//后序遍历
{
    if(T==NULL)
        return;
    PostOrderTraverse(T->lchild);
    PostOrderTraverse(T->rchild);
    printf("%c ",T->data);
}
```

## 二叉树的创建
```c
//我在这里实现的是，二叉树的前序遍历方式创建，如果要使用中序或者后序的方式建立二叉树，只需将生成结点和构造左右子树的顺序改变即可
 void CreateBiTree(BiTree *T)
  {
      char ch;
      scanf("%c",&ch);
      if(ch=='#')
          *T=NULL;
      else
     {
         *T=(BiTree  )malloc(sizeof(BiTNode));
         if(!*T)
             exit(-1);
          (*T)->data=ch;
          CreateBiTree(&(*T)->lchild);
         CreateBiTree(&(*T)->rchild);
      }
 }
```


# 树与森林

## 树和森林与二叉树之间的转换

### 树转为二叉树
1. 加线。就是在所有兄弟结点之间加一条连线；
2. 抹线。就是对树中的每个结点，只保留他与第一个孩子结点之间的连线，删除它与其它孩子结点之间的连线； 
3. 旋转。就是以树的根结点为轴心，将整棵树顺时针旋转一定角度，使之结构层次分明。
![](.img/树转为二叉树.png)

### 森林专为二叉树
森林是由若干棵树组成，可以将森林中的每棵树的根结点看作是兄弟，由于每棵树都可以转换为二叉树，所以森林也可以转换为二叉树。

将森林转换为二叉树的步骤是：
1. 先把每棵树转换为二叉树；
2. 第一棵二叉树不动，从第二棵二叉树开始，依次把后一棵二叉树的根结点作为前一棵二叉树的根结点的右孩子结点，用线连接起来。当所有的二叉树连接起来后得到的二叉树就是由森林转换得到的二叉树。

![](./.img/森林专为二叉树.png)

### 二叉树转为树
二叉树转换为树是树转换为二叉树的逆过程，其步骤是：
1. 若某结点的左孩子结点存在，将左孩子结点的右孩子结点、右孩子结点的右孩子结点……
   都作为该结点的孩子结点，将该结点与这些右孩子结点用线连接起来；
2. 删除原二叉树中所有结点与其右孩子结点的连线；
3. 整理（1）和（2）两步得到的树，使之结构层次分明

![](./.img/二叉树转为树.png)

## 树和森林的遍历
### 树的遍历
* 先根遍历: 先访问树的根节点，依次先根遍历各棵子树。也就是其对应二叉树的先序遍历
* 后根遍历: 先依次后根遍历各棵子树，然后访问树根结点。也就是对应二叉树的中序遍历

### 森林的遍历
* 先序遍历森林：森林非空，依次先序遍历森林中的每一棵树
* 中序遍历森林：森林非空，依次中序遍历森林中的每一棵树

# 哈夫曼树(最优二叉树)

哈夫曼树是一类带权路径长度最短的树。
* 路径：树中一个点到另一个点之间的通路称为两个结点之间的路径，通路上分支数目称为路径长度

* 树路径长度: 根节点到叶子结点之间路径长度之和

* 树的带权路径长度：$WPL=\sum_{k=1}^nw_kl_k$，其中n为带权叶子结点数目，
  $w_k$为叶子结点的权值，$l_k$为根节点到叶子结点带权路径长度
  
## 哈夫曼树的构造方法
**依据哈弗曼树的定义，一棵二叉树要使其WPL值最小，必须使权值越大的叶子结点越靠近根结点，而权值越小的叶子结点越远离根结点。**

哈弗曼根据这一特点提出了一种构造最优二叉树的方法，其基本思想如下：
1. 根据给定的n个权值${w1, w2, w3 ... wn }$，构造n棵只有根节点的二叉树，令起权值为wj
2. 在森林中选取两棵根节点权值最小的树作为左右子树，构造一颗新的二叉树，置新二叉树根节点权值为其左右子树根节点权值之和。注意，左子树的权值应小于右子树的权值。
3. 从森林中删除这两棵树，同时将新得到的二叉树加入森林中。（换句话说，之前的2棵最小的根节点已经被合并成一个新的结点了）
4. 重复上述两步，直到只含一棵树为止，这棵树即是哈弗曼树


## 哈夫曼编码
讲哈夫曼树的左分支编码为0，右分支编码为1，则每个叶子结点代表的字符编码就是从根结点
到叶子结点路径上0和1标记组成的串。

解码过程就是按照哈夫曼编码从哈夫曼树的根节点开始，遇到0就走左子树，遇到1就走右子树
，到达叶子几点读取出字符；再从树根开始继续，直到编码读取完成。


# 二叉排序树(二叉查找树)
是空树或者具有如下性质
1. 左子树非空，则左子树中结点的值小于根节点值
2. 右子树非空，则右子树中结点的值大于根节点值
3. 左右子树也是二叉排序树

**二叉排序树的中序遍历得到的是递增有限的序列**





