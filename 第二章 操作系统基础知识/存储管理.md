# 一、存储管理

存储器管理的对象时主存储器(主存、内存)。存储器时计算机系统中关键性资源，是存放各种信息的主要场所。对存储器的有效管理可以提高存储器的利用率，对系统性能有重大影响。存储管理的功能是**分配和回收主存空间、提高主存的利用率、扩充主存、对主存信息实现有效保护**

## 1.1 基本概念

1. 存储器的基本结构

    存储器的功能是保存数据，发展方向是**高速度、大容量、小体积**。
    
    一般存储器结构有"寄存器-主存-外存"结构和"寄存器-缓存-主存-外存"结构。

    存储组织的功能主要是在存储技术和CPU寻址技术许可的范围内组织和管理存储结构，使得个层次的存储器都处于均衡的繁忙状态。
    
    * **虚拟地址**。对于程序员而言，数据的存放地址由符号决定，称为符号名地址(名地址)。从0号开始编址，并顺序分配所有的符号名所对应的地址单元。**符号名地址不是主存中的真实地址，因此称为相对地址、程序地址、逻辑地址、虚拟地址**
    * **地址空间**。程序中由符号名组成的空间称为名空间。源程序经过汇编或编译形成二进制的目标程序。在目标程序中， **程序指令和数据位置按照字或字节单位根据它们的相对顺序来确定，称为相对地址**。程序中由相对地址组成的空间叫做逻辑地址空间，逻辑地址空间通过 **地址再定位机** 转换到绝对地址空间(物理地址空间)。

    **逻辑地址空间(地址空间)是逻辑地址的集合，物理地址空间(存储空间)是物理地址的集合**。

2. 地址重定位

    **将逻辑地址转换成主存物理地址的过程称为地址重定位。** 在可执行程序文件装入时，需要解决可执行文件中**地址(指令和数据)**与**主存地址**的对应关系，由操作系统的装入程序和地址重定位机构来完成。地址重定位分为**静态地址重定位和动态地址重定位**
    * **静态地址重定位**。程序装入主存时已经完成了逻辑地址到物理地址的变换，在程序执行期间不会再发生变化。优点是**无须硬件地址变换机构支持，只要求程序本身是可重定位的**只对那些要修改的地址部分具有某种标识，由专门设计的程序来完成。早期操作系统多数都采用这种方法。缺点是**必须给作业分配一个连续的存储区域，作业执行期间不能扩充存储空间，也不能再主存中移动**，多个作业难以共享主存中同一程序副本和数据。

    * **动态地址重定位**。程序运行期间完成逻辑地址到物理地址的变换。依赖硬件地址变换机构，例如，基地址寄存器(BR)。优点是**程序执行期间可以换入和换出主存；程序可以再主存中移动(把主存碎片集中起来，充分利用空间)**。不用给程序分配连续的主存空间，可以较好地利用较小地主存块，可以实现共享。

## 1.2 存储管理方案

存储管理地目的是 **解决多个用户使用主存地问题** 。管理方案主要包括**分区、分页、分段、段页式、虚拟**存储管理


## 1.3 分区存储管理

分区存储管理式早期地存储器管理方案，基本思想是把**主存地用户区划分成若干个区域，每个区域分配给一个用户地作业使用，**并限定只能再自己区域中运行。按分区地方式不同分为**固定分区、可变分区、可重定位分区**

1. **固定分区**。一种静态分区方式，在系统生成时已将主存划分为若干分区，每个分区大大小可不等。操作系统 **通过主存分配情况表管理主存** 。存在地问题是**已经分配地分区中存在未用空间(程序或作业地大小不可能刚好等于分区大小)**，造成空间浪费；将这样地空间称为**零头或内碎片**

2. **可变分区**。一种动态分区方式。存储空间在作业装入主存是划分( **分区个数可变，分区大小刚好等于作业大小** )。可变分区需要两种管理表格；一是**已分配表**, 用于记录已分配分区情况；二是**未分配表**，记录未分配地情况。
   
    请求和释放分区的算法有**最佳适应算法、最差适应算法、首次适应算法、循环首次适应算法**。

    可变分区的优点是**分配更灵活、提高了主存的利用率**，缺点是**由于内存的不断分配与回收，必定会出现不连续的小的空闲区(尽管总和大于某个作业，但是也不能分配)，通常称这样的空间为碎片。** 解决碎片的方案是**向一个方向移动已分配的作业，使零散的空散区连成一片。**

3. **可重定位分区**。解决碎片问题简单而有效的方法。基本思想是**移动所有已分配好的分区，使之成为连续区域**。分区“靠拢”的时机是 **用户请求空间得不到满足时或某个作业执行完毕** 时。通常情况是**用户请求空间得不到满足时进行**，分区"靠拢"时会导致地址发生变化，有地址重定位问题。


4. **分区保护**。目的时防止未经核准的用户访问分区，常用以下两种方式

    * **上界/下界寄存器保护**。上界寄存器中存放的是作业装入时的地址，下界寄存器装入的是作业结束地址，形成的物理地址必须满足条件$上界寄存器\le 物理地址 \le 下界寄存器$

    * **基址/限长寄存器保护**。基址寄存器中存放的作业的装入地址，限长寄存器装入的是作业的长度，形成的物理地址必须满足条件$基址寄存器\le 物理地址 \le 基址寄存器+限长寄存器$


## 1.4 分页存储管理

尽管分区管理方案是解决多道程序共享主存的可行方案，但是存在**用户进程必须装入连续的地址空间内**的问题。若没有满足用户要求的连续空间，需要进行分区靠拢操作(非常消耗系统时间)

### 1.4.1 纯分页存储管理
1. **分页原理** 
   
    将进程的地址空间划分成若干大小不相等的区域，称为页。将主存空间划分为与页相同大小的若干物理块，称为块或页框。为进程分配主存时，将进程中若干页分别装入多个不相等的块中。

2. **地址结构**
   
    分页系统的地址有两部分组成
    ![](https://images.gitee.com/uploads/images/2021/0122/173251_df650df1_7841459.jpeg "分页地址结构.jpg")
    * 第一部分: 页码$P$
    * 第二部分: 页内地址(页偏移$d$)
    * 如果地址长度为32位，其中0~11位为页内地址(每页的大小为4KB)；12~31位为页号，所以允许的地址空间大小最多为1MB个页

3. **页表**

    将进程的每一页离散的分配到内存的多个物理块中后，系统应保证能够在内存中找到每个页面所对应的物理块。因此，系统为每个进程建立了一张页面映射表，简称页表，如下图所示
    ![](https://images.gitee.com/uploads/images/2021/0122/175405_6209ba89_7841459.jpeg "地址映射.jpg")

    每个页在页表中占一个表项，记录程序中的某页在内存中对应的物理块号。进程执行时，系统通过查找页表，就可以找到每页所对应的物理块号，实现页号到物理块号的地址映射。

4. **地址变换机构**

    基本任务是利用页表把用户程序中的逻辑地址变换成内存中的物理地址，即 **将用户程序中的页号变换成内存中的物理块号** 。
    * 页表寄存器：存放页表的起始地址和页表的长度。
    
    程序未执行时，每个进程对应的页表的起始地址和长度存放在进程的PCB中。当进程被调度时，将它们转入页表寄存器。

    进程地址变换时，系统将页号和页表长度进行比较，如果 **页号大于等于页表寄存器中的页表长度$L$，则发生越界中断** 。 **没有出现越界中断，则根据页表寄存器中的页表起始地址和页号计算该页在页表项中的位置得到该页的物理块号，将物理块号装入物理地址寄存器中** 。与此同时，将 **逻辑地址寄存器中页内地址直接装入物理地址寄存器的块内地址字段中，完成逻辑地址到物理地址的变换** 。

### 1.4.2 快表

页式存储管理至少需要两次访问内存，第一次 **访问页表** ，得到数据的物理地址；第二次访问是 **存取数据** 。采用间接寻址访问数据，则还需要进行地址变换。为了提高内存访问速度，可以在地址映射机构中增加一组高速寄存器，用于保存页表(**需要大量的硬件开销**)；也可以在地址映射机构中增加一个小容量的联想存储器(由高速存储器组成)，称为快表，用来保存当前访问频率高的少数活动页的页号以及相关信息。

联想存储器存放的只是当前进程最活跃的少数几页物理块号，当用户程序需要访问数据时，在联想存储器中找出该数据所在的逻辑页号对应的物理块号，与页内地址拼接形成物理地址；若没找到对应的物理块号，则地址映射仍通过内存的页表进行。**查找联想存储器和查找内存页表是并行进行的**，一旦在联想存储器中找到符合的逻辑页号时，停止查找内存页表。若找不到，就通过查找内存页表得到物理页号

## 1.5 分段存储管理

 **段是信息的逻辑单位** ，优点是 **易于实现段的共享** ，即 **允许若干个进程共享一个或多个段，可简单的实现段的保护** 。

在实现程序和数据的共享式，常常以信息的逻辑单位为基础。 _分页系统中每一页只是存放信息的物理单位(本身没有完整的意义)，因而不便于实现信息共享_ 。段却是信息的逻辑单位，有利于信息的共享和保护。

实际系统中， **有些数据段不会不断地增长，而事先却无法知道数据段会增长到多大** ，分段存储管理方式可以较好地解决这个问题。


1. 分段的基本原理

    作业的地址空间分为若干段，每段是一组完整的逻辑信息，如**主程序段、子程序段、数据段、堆栈段等**，每段有自己的名字，都是从0开始编址的一段连续的地址空间，各段长度不等。分段地址结构如下图
    ![](https://images.gitee.com/uploads/images/2021/0122/190301_4bb197eb_7841459.png "屏幕截图.png")
    逻辑地址由段号(名)和段内地址两部分组成，允许一个作业最多有64K 段，每段最大长度为64KB.

    地址变换机构如下图

    ![](https://images.gitee.com/uploads/images/2021/0122/190844_ef0ffacb_7841459.jpeg "1611313676676.jpg")
    为每段分配一个连续的分区，进程中的各段可以离散的分配到内存的不同分区。在系统中为每个进程建立一张段映射表，简称“段表”。每段在表中占有一表项，其中记录了该段在内存中的起始地址(基址)和段的长度。
    * 利用段表寄存器中的段表长度与逻辑地址中的段号比较，若段号超过段表长度则产生越界中断。
    * 进程在执行中，通过查找段表找到每个段所对应的内存区，实现逻辑段带物理内存区的映射。

## 1.6 虚拟存储管理

前面的存储管理方案，必须为每个作业分配足够的空间，以便于装入全部信息。当主存空间不能满足作业要求时，作业便无法装入主存执行。

**如果一个作业的部分内容装入主存便可以开始运行，其余部分暂时留在磁盘上，需要时再装入主存，这样可以有效的利用主存空间** 。以用户角度来看，主存容量将比实际容量大，人们把 **这样的存储器称为虚拟存储器** ，为了扩大主存内容采用的一种设计方法，容量是由计算机的地址结构决定。

### 1.6.1 程序局部性原理
 **在一段时间内，程序的执行仅局限于某个部分**，这是程序执行时呈现出的**局部性规律** 。相应地，能够访问地存储空间也局限于某个区域内。表现在 **时间局部性和空间局部性** 两个方面
1. **时间局部性**。程序地某条指令一旦执行，则不久地将来该指令可能再次被执行；某个存储单元被访问，则不久后该存储单元可能再次被访问。原因是**程序中存在着大量地循环操作**

2. **空间局部性**。一旦程序访问了某个存储单元，则不久将来，其附近地存储单元也最有可能被访问，即**程序在一段时间内访问地地址，可能集中在一定范围内**。原因是**程序是顺序执行的**


### 1.6.2 虚拟存储器的实现

虚拟存储器具有请求调入功能和置换功能，可以把作业的一部分装入主存使其开始运行，能从逻辑上对主存容量进行扩充。虚拟存储器的容量由**主存和外存容量以及CPU可寻址的范围**一起决定，其运行速度接近于主存速度，成本接近于外存。虚拟存储器由以下三种方式实现。

1. 请求分页系统

    在分页系统的基础上，增加了 **请求调页和页面置换** 功能所形成的页式虚拟存储系统。允许只装入若干页的用户程序和数据(而非全部程序)，就可以启动允许，以后再通过调页功能和页面置换功能，陆续把将要使用的页面调入主存，同时把暂不运行的页面置换到外存上，置换时以页面为单位。

2. 请求分段系统

    在分段系统的基础上，增加**请求调段和分段置换**功能所形成的段式虚拟存储系统。允许只装入若干段(非全部段)的用户进程和数据，就可以运行。以后再通过调用段功能和置换功能将不运行的段调出，同时调入将要运行的段，置换单位以段为单位。

3. 请求段页式系统

    在段页式系统的基础上，增加了**请求调段和分段置换**功能形成的段页式虚拟存储系统。

### 1.6.3 请求分页管理的实现

请求分页是在纯分页系统的基础上，增加了 **请求调页功能和页面置换功能** 所形成的页式虚拟存储系统，是目前 **常用的一种虚拟存储器的方式** 。

由于只将程序的一部分调入主存，还有一部分仍在外存上，所以需要在页表上增加若干项(状态位、访问字段、辅存地址等)，供程序(数据)在换进、换出时参考。

在请求分页系统中，每当要访问的页面不在主存时，便产生一个缺页中断，请求调入所缺的页。缺页中断与一般中断的区别是**缺页中断在指令执行期间产生和处理中断信号；一般中断在一条指令结束后，下一条指令开始执行前检查和处理中断信号。**缺页中断返回到被中断指令的开始重新执行该指令；一般中断返回到下一条指令执行。一条指令在执行期间，可能会产生多次缺页中断。

### 1.6.4 页面置换算法

进程运行时，如果发生缺页而内存中又无空闲块时，必须从内存中调出页程序或数据送入磁盘的对换区，才能保证进程能够正常运行。**根据页面置换算法来确定调出那个页面，页面置换算法的好与坏直接影响到系统的性能。**

如果刚被置换出的页面很快又被访问，需要重新调入，使得系统频繁的更换页面，以致一个进程在运行时将大量时间花费在页面置换上，这样的状态称进程发生了"抖动(颠簸)"。常用的页面置换算法如下。

1. **最佳(Optimal)置换算法** ：选择永不使用，或者是在最长时间内不再访问的页面置换出去。缺点是 **页面在未来最长时间内不在访问很难估计** 。

2. **先进先出(FIFO)置换算法** ：淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面予以淘汰。性能较差，会发生Belady异常现象(进程未分配它所要的全部页面，有时会出现分配页面数增多但是缺页率反而提高的异常现象)

3. **最近最少使用(Least Recenntly Used, LRU)置换算法** ：选择最近最少使用的页面淘汰，系统在每个页面设置一个访问字段，用以纪律这个页面自上次访问以来经历的时间$T$，淘汰时选择$T$最大的页面。

4. **最近未用(Not Used Recently, NUR)置换算法** ：将最近未被引用过的页面换出。为每个页面设置一个访问位，将内存中的所有页面通过链接指针连成循环队列。页面被访问时，访问位置为1。淘汰页面时，选择访问位是0的页面换出；若为1，则从新置为0，暂不换出该页，在循环队列中检查下一个页面，直到访问位为0的页面为止。







